def solution(k, m, score):
    answer = []
    score.sort(reverse=True)
    for i in range(0, len(score)+1, m):
        if len(score[i:i+m]) == m:
            answer.append(min(score[i:i+m])*len(score[i:i+m]))
    return sum(answer)

# m = 한 상자에 들어갈 사과의 개수
# k = 최대 점수

# 몇상자를 팔 수 있나 -> len(score)//m 12//3 -> 4

# score를 큰 순으로 정렬, 상자길이로 짤라감 안남을때까지 반복

# 간단한 슬라이싱으로 풀이
def solution(k, m, score):
    return sum(sorted(score)[len(score)%m::m])*m

# [1,1,1,2,2,3,3] / [3::4]=[2]*4 -> [2,2,2,2]
# [1,1,2,2,2,2,4,4,4,4,4,4] / [0::3]=[1,2,4,4]*3 -> [1,2,4,4,1,2,4,4,1,2,4,4,]

sorted(score): 주어진 score 리스트를 정렬합니다. 정렬된 리스트를 반환합니다.

len(score)%m은 리스트를 m 개의 그룹으로 나눌 때 마지막 그룹의 첫 번째 인덱스를 나타냅니다.

이 코드의 핵심은 부분 리스트를 선택하는 부분입니다. 
len(score)%m은 마지막 그룹의 첫 번째 인덱스를 나타내기 때문에, m 간격으로 슬라이싱하여 그룹의 첫 번째 요소들을 선택하게 됩니다. 
선택된 부분 리스트의 최소값에 m을 곱해주면 해당 그룹에서 얻을 수 있는 최대 이익이 됩니다. 
그리고 이러한 최대 이익들을 모두 합하여 전체 최대 이익을 구합니다.
예를 들어, k = 3, m = 4, score = [1, 2, 3, 1, 2, 3, 1]인 경우에는 [2, 3, 2, 3]으로 구성된 부분 리스트를 선택하게 되며, 
각각의 최소값은 2, 3, 2, 3이고, 각각의 최대 이익은 8입니다. 따라서 최종적으로 8이 반환됩니다.
